generator zod {
  provider = "zod-prisma-types"
  output   = "../../../packages/shared/zod/generated"
}

generator client {
  provider = "prisma-client-js"
}

generator erd {
  provider = "prisma-erd-generator"
  output   = "ERD.svg"
  // theme    = "forest"
  // erdDebug = false
  // disabled = true
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// connection_request.type
enum ConnectionType {
  friend
  dating
}

/// connection_request.status
enum ConnectionStatus {
  pending
  accepted
  rejected
  blocked
}

enum Gender {
  male
  female
  non_binary
  other
  unspecified
}

enum PreferenceGender {
  male
  female
  non_binary
  any
}

enum RelationshipStatus {
  single
  in_relationship
  married
  other
  unspecified
}

/// Tag.scope  (friend vs. dating)
enum TagScope {
  friend
  dating
}

model Tag {
  id   Int      @id @default(autoincrement())
  name String   @unique
  type TagScope

  friendProfileTags ProfileTag[]
}

model ProfileTag {
  id    String @id @default(cuid())
  tag   Tag    @relation(fields: [tagId], references: [id])
  tagId Int

  profile         Profile        @relation(fields: [profileId], references: [id])
  profileId       String
  datingProfile   DatingProfile? @relation(fields: [datingProfileId], references: [id])
  datingProfileId String?

  @@unique([profileId, tagId])
}

model DatingPreference {
  userId     String           @id
  prefGender PreferenceGender @default(any)
  prefAgeMin Int?
  prefAgeMax Int?

  profile DatingProfile @relation(fields: [userId], references: [userId], onDelete: Cascade)
}

model ConnectionRequest {
  id         String           @id @default(cuid())
  fromUser   User             @relation("RequestsSent", fields: [fromUserId], references: [id], onDelete: Cascade)
  fromUserId String
  toUser     User             @relation("RequestsReceived", fields: [toUserId], references: [id], onDelete: Cascade)
  toUserId   String
  type       ConnectionType
  status     ConnectionStatus
  createdAt  DateTime         @default(now())

  @@unique([fromUserId, toUserId, type])
}

model User {
  id                      String    @id @default(cuid())
  email                   String    @unique
  tokenVersion            Int       @default(0)
  loginToken              String?   @unique
  loginTokenExp           DateTime?
  isRegistrationConfirmed Boolean   @default(false)
  isAccountDisabled       Boolean   @default(false)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastLoginAt DateTime?

  profile       Profile?       @relation
  datingProfile DatingProfile?

  // Sent/received connection requests
  requestsSent     ConnectionRequest[] @relation("RequestsSent")
  requestsReceived ConnectionRequest[] @relation("RequestsReceived")
}

model Profile {
  id         String @id @default(cuid())
  publicName String
  intro      String
  country    String @default("")
  city       String @default("")

  lookingFor ConnectionType[]

  latitude  Float?
  longitude Float?

  isActive   Boolean @default(false)
  isReported Boolean @default(false)

  // relations
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])

  tags ProfileTag[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ProfileImage {
  id       String @id @default(cuid())
  mimeType String
  userId   String

  altText        String?
  storagePath    String


  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

}

model DatingProfile {
  id           String             @id @default(cuid())
  publicName   String
  intro        String
  country      String             @default("")
  city         String             @default("")
  birthday     DateTime?
  gender       Gender             @default(unspecified)
  relationship RelationshipStatus @default(unspecified)
  hasKids      Boolean?           @default(false)

  lookingFor ConnectionType[]

  latitude  Float?
  longitude Float?

  isActive   Boolean @default(false)
  isReported Boolean @default(false)

  // relations
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])

  preference DatingPreference?

  tags ProfileTag[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
